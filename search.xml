<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>单链表的定义和基本操作</title>
      <link href="/2023/05/16/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/05/16/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h1><ul><li>什么是单链表</li><li>用代码定义一个单链表</li><li>两种实现1、带头结点 2、不带头结点</li></ul><p><strong>单链表（链式存储结构）</strong></p><p><strong>优点</strong>：不要求大片连续空间，改变容量方便</p><p><strong>缺点</strong>：不可随机存取，要耗费一定空间存放指针</p><h3 id="用代码定义一个单链表"><a href="#用代码定义一个单链表" class="headerlink" title="用代码定义一个单链表"></a>用代码定义一个单链表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span><span class="comment">//定义单链表结点类型</span></span><br><span class="line">ElemType data;<span class="comment">//每个结点存放一个数据元素</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span><span class="comment">//指针指向下一个结点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">p</span> =</span> (<span class="keyword">struct</span> LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>typedef &lt;数据类型&gt; &lt;别名&gt;</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> <span class="title">LNode</span>;</span></span><br><span class="line">LNode *p = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span><span class="comment">//定义单链表结点类型</span></span><br><span class="line">ElemType data;<span class="comment">//每个结点存放一个数据元素</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span><span class="comment">//指针指向下一个结点</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure><p>​    要表示一个单链表时，只需声明一个头结点L,指向单链表的第一个结点</p><p>​LNode *L;    &#x2F;&#x2F;  <strong>强调返回的是一个结点</strong></p><p>或 : LinkList L;     &#x2F;&#x2F; <strong>强调这是一个单链表</strong></p><p>&#x2F;&#x2F;声明一个指向单链表的第一个结点的指针</p><h3 id="不带头结点的单链表"><a href="#不带头结点的单链表" class="headerlink" title="不带头结点的单链表"></a>不带头结点的单链表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span><span class="comment">//定义单链表结点类型</span></span><br><span class="line">ElemType data;<span class="comment">//每个结点存放一个数据元素</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span><span class="comment">//指针指向下一个结点</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span> &#123;</span><br><span class="line">L = <span class="literal">NULL</span>;<span class="comment">//空表 暂时还没有任何结点</span></span><br><span class="line">    <span class="comment">//防止脏数据</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">LinkList L;<span class="comment">//声明一个指向单链表的指针</span></span><br><span class="line"><span class="comment">//初始化一个空表</span></span><br><span class="line">InitList(L);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带头结点的单链表</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList&amp; L)</span> &#123;</span><br><span class="line">L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)) <span class="comment">//分配一个头结点</span></span><br><span class="line"><span class="keyword">if</span> (L == <span class="literal">NULL</span>)<span class="comment">//内存不足，分配失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">L-&gt;next = <span class="literal">NULL</span>;<span class="comment">//头结点之后暂时没有结点</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkList L)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (L-&gt;next == <span class="literal">NULL</span>); <span class="comment">//判断单链表是否为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="知识回顾与总结"><a href="#知识回顾与总结" class="headerlink" title="知识回顾与总结"></a>知识回顾与总结</h2><p><img src="/../images/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AE%9A%E4%B9%89.png"></p><h1 id="单链表的插入删除"><a href="#单链表的插入删除" class="headerlink" title="单链表的插入删除"></a>单链表的插入删除</h1><h3 id="按位序插入（带头结点）"><a href="#按位序插入（带头结点）" class="headerlink" title="按位序插入（带头结点）"></a><strong>按位序插入（带头结点）</strong></h3><p><strong>ListInsert(&amp;L,i,e);</strong> 插入操作。在表L中的第i个位置</p><p>插入指定元素e。  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList&amp; L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LNode* p; <span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>; <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">p = L;<span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123; <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="comment">//i值不合法</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">s-&gt;data = e;</span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = s;<span class="comment">//将结点s连到p之后</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//插入成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="按位序插入（不带头结点）"><a href="#按位序插入（不带头结点）" class="headerlink" title="按位序插入（不带头结点）"></a>按位序插入（不带头结点）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList&amp; L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">       LNode *s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;next = L;</span><br><span class="line">        L = s; <span class="comment">//头指针指向新结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">LNode* p; <span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">1</span>; <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">p = L;<span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123; <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="comment">//i值不合法</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">s-&gt;data = e;</span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = s;<span class="comment">//将结点s连到p之后</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//插入成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="指定结点的后插操作"><a href="#指定结点的后插操作" class="headerlink" title="指定结点的后插操作"></a>指定结点的后插操作</h3><p>&#x2F;&#x2F;后插操作：在p结点之后插入元素e</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextNode</span><span class="params">(LNode* p, ElemType e)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line"><span class="keyword">if</span> (s == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">s-&gt;data = e;<span class="comment">//用结点s报存数据元素e</span></span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = s;<span class="comment">//将结点s连到p之后</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;在第i个位置插入元素e(带头结点)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList&amp; L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LNode* p; <span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;<span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">p = L;<span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;<span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line"><span class="keyword">if</span> (s = <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">s-&gt;data = e;</span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = s;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指定结点的前插操作"><a href="#指定结点的前插操作" class="headerlink" title="指定结点的前插操作"></a>指定结点的前插操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前插操作：在p结点之前插入元素e</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertPriorNode</span><span class="params">(LNode* p, ElemType e)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line"><span class="keyword">if</span> (s == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = s;    <span class="comment">//新结点s连到p之后</span></span><br><span class="line">s-&gt;data = p-&gt;data;<span class="comment">//将p中元素复制到s中</span></span><br><span class="line">p-&gt;data = e;<span class="comment">//p中元素覆盖为e</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按位序删除-带头结点"><a href="#按位序删除-带头结点" class="headerlink" title="按位序删除(带头结点)"></a>按位序删除(带头结点)</h3><p><strong>ListDelete(&amp;L,i,&amp;e):</strong> 删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。</p><p>  删除表L中第i个位置（找到第i-1个结点，将其指针指向第i+1个结点，并释放第i个结点。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(LinkList&amp; L, <span class="type">int</span> i, ElemType&amp; e)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LNode* p;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">p = L;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>)  <span class="comment">//第i-1个结点之后已无其他结点</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LNode* q = p-&gt;next;<span class="comment">//令q指向被删除结点</span></span><br><span class="line">e = q-&gt;data;<span class="comment">//用e返回元素的值</span></span><br><span class="line">p-&gt;next = q-&gt;next;<span class="comment">//将*q结点从链中&quot;断开&quot;</span></span><br><span class="line"><span class="built_in">free</span>(q);<span class="comment">//释放结点的存储空间</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="指定结点的删除"><a href="#指定结点的删除" class="headerlink" title="指定结点的删除"></a>指定结点的删除</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除指定结点p</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNode</span><span class="params">(LNode* p)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LNode* q = p-&gt;next; <span class="comment">//令q指向*p的后继结点</span></span><br><span class="line">p-&gt;data = p-&gt;next-&gt;data;<span class="comment">//和后继结点交换数据域</span></span><br><span class="line">p - next = q-&gt;next; <span class="comment">//将*q结点从链中“断开&quot;</span></span><br><span class="line"><span class="built_in">free</span>(q);<span class="comment">//释放后继结点的存储空间</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="知识回顾与考点"><a href="#知识回顾与考点" class="headerlink" title="知识回顾与考点"></a>知识回顾与考点</h2><p><img src="/../images/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4.png"></p><h1 id="单链表的查找"><a href="#单链表的查找" class="headerlink" title="单链表的查找"></a>单链表的查找</h1><h3 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按位查找，返回第i个元素（带头结点）</span></span><br><span class="line">LNode* <span class="title function_">GetELem</span><span class="params">(LinkList L, <span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">LNode* p;  </span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">p = L;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i) &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按值查找，找到数据域==e的结点</span></span><br><span class="line">LNode* <span class="title function_">LocateELem</span><span class="params">(LinkList L, ElemType e)</span> &#123;</span><br><span class="line">LNode* p = L-&gt;next;<span class="comment">//从第1个结点开始查找数据域为e的结点</span></span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e)</span><br><span class="line">p = p-&gt;next;</span><br><span class="line"><span class="keyword">return</span> p; <span class="comment">//找到后返回该结点指针，否则返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求表的长度"><a href="#求表的长度" class="headerlink" title="求表的长度"></a>求表的长度</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求表的长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Length</span><span class="params">(LinkList L)</span> &#123;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">LNode* p = L;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="知识回顾与重要考点"><a href="#知识回顾与重要考点" class="headerlink" title="知识回顾与重要考点"></a>知识回顾与重要考点</h3><p><img src="/../images/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构,单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序表的查找</title>
      <link href="/2023/05/13/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
      <url>/2023/05/13/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序表的按位查找"><a href="#顺序表的按位查找" class="headerlink" title="顺序表的按位查找"></a>顺序表的按位查找</h1><p><strong>GetElem(L.i)</strong>: 按位查找操作。获取表L中第i个位置的元素的值。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType data[MaxSize];  <span class="comment">//用静态的“数组”存放数据</span></span><br><span class="line"><span class="type">int</span> length;<span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;<span class="comment">//顺序表的类型定义（静态分配方式）</span></span><br><span class="line"></span><br><span class="line">ElemType <span class="title function_">GetElem</span><span class="params">(SqList L, <span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态分配方式</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10    <span class="comment">//顺序表的初始长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType* data;<span class="comment">//指示动态分配数组的指针</span></span><br><span class="line"><span class="type">int</span> MaxSize;<span class="comment">//顺序表的最大容量</span></span><br><span class="line"><span class="type">int</span> length;<span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SeqList;<span class="comment">//顺序表的类型定义（动态分配方式）</span></span><br><span class="line"></span><br><span class="line">ElemType <span class="title function_">GetElem</span><span class="params">(SeqList L, <span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(1):由于顺序表的各个数据元素在内存中连续存放,因此可以根据起始地址和数据元素大小立即找到第i个元素—―“<strong>随机存取</strong>”特性</p><h1 id="顺序表的按值查找"><a href="#顺序表的按值查找" class="headerlink" title="顺序表的按值查找"></a>顺序表的按值查找</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10    <span class="comment">//顺序表的初始长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType* data;<span class="comment">//指示动态分配数组的指针</span></span><br><span class="line"><span class="type">int</span> MaxSize;<span class="comment">//顺序表的最大容量</span></span><br><span class="line"><span class="type">int</span> length;<span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SeqList;<span class="comment">//顺序表的类型定义（动态分配方式）</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SeqList L, ElemType e)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line"><span class="keyword">if</span> (L.data[i] == e)</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span>;  <span class="comment">//数组下标为i的元素值等于e，返回其位序i+1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//退出循环说明查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>L.data[i] &#x3D;&#x3D; e  基本数据类型：int，char，double，float 等可以直接用运算符“&#x3D;&#x3D;”比较</p><p><strong>注意：c语言中，结构体的比较不能直接用“&#x3D;&#x3D;”</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a.num == b.num &amp;&amp; a.people == b.people)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;相等&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;不相等&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要依次对比各个分量来判断两个结构体是否相等</p><p>if(L.data[i]&#x3D;&#x3D;e)</p><p>最好情况：目标元素在表头<br>            循环1次：<strong>最好时间复杂度&#x3D;O(1)</strong><br>最坏情况：目标元素在表尾<br>            循环n次：<strong>最坏时间复杂度&#x3D;O(n);</strong><br>平均情况：假设目标元素出现在任何一个位置的概率相同，都是1&#x2F;n<br>            目标元素在第1位，循环1次;在第2位，循环2次;…….:在第n位，循环n次,    <strong>平均时间复杂度&#x3D;O(n)</strong></p><h1 id="知识回顾与重要考点"><a href="#知识回顾与重要考点" class="headerlink" title="知识回顾与重要考点"></a>知识回顾与重要考点</h1><p><img src="/../images/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构,顺序表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序表的插入删除</title>
      <link href="/2023/05/12/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4/"/>
      <url>/2023/05/12/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序表的基本操作——插入"><a href="#顺序表的基本操作——插入" class="headerlink" title="顺序表的基本操作——插入"></a>顺序表的基本操作——插入</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10 <span class="comment">//定义最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">int</span> data[MaxSize]; <span class="comment">//用静态的&quot;数组&quot;存放数据元素</span></span><br><span class="line"><span class="type">int</span> length;<span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;<span class="comment">//顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ListInsert</span><span class="params">(SqList&amp; L, <span class="type">int</span> i, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = L.length; j &gt;= i; j--)<span class="comment">//将第i个元素及之后的元素后移</span></span><br><span class="line">L.data[j] = L.data[j - <span class="number">1</span>]; </span><br><span class="line">L.data[i - <span class="number">1</span>] = e;<span class="comment">//在位置i处放入e</span></span><br><span class="line">L.length++;<span class="comment">//长度+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SqList&amp; L)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i++)</span><br><span class="line">L.data[i] = <span class="number">0</span>;<span class="comment">//将所有数据元素设置为默认初始值</span></span><br><span class="line">L.length = <span class="number">0</span>;<span class="comment">//顺序表初始长度为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SqList L;<span class="comment">//声明一个顺序表</span></span><br><span class="line"><span class="built_in">InitList</span>(L); <span class="comment">//初始化顺序表</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="built_in">ListInsert</span>(L, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>void ListInsert(SqList&amp; L, int i, int e)  基本操作：在L的位序i处插入元素e</p><p>L.data[j] &#x3D; L.data[j - 1];   注意位序，数组下标的关系，并从后面的元素依次后移</p><p><strong>好代码  具有“健壮性”</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(SqList&amp; L, <span class="type">int</span> i, <span class="type">int</span> e)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L.length + <span class="number">1</span>)<span class="comment">//判断i的范围是否有效</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (L.length &gt; MaxSize)<span class="comment">//当前存储空间已满，不能插入</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = L.length; j &gt;= i; j--)<span class="comment">//将第i个元素及之后的元素后移</span></span><br><span class="line">L.data[j] = L.data[j - <span class="number">1</span>]; </span><br><span class="line">L.data[i - <span class="number">1</span>] = e;<span class="comment">//在位置i处放入e</span></span><br><span class="line">L.length++;<span class="comment">//长度加1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入操作的时间复杂度</p><p>L.data[j] &#x3D; L.data[j - 1]; </p><p><strong>关注最深层循环语句的执行次数与问题规模n的关系</strong></p><p>最好情况：新元素插入到表尾，不需要移动元素</p><p>​i&#x3D;n+1，循环0次；<strong>最好时间复杂度&#x3D;O(1)</strong></p><p>最坏情况：新元素插入到表头，需要将原有的n个元素全都向后移动</p><p>​i&#x3D;1，循环n次；<strong>最坏时间复杂度&#x3D;O(n)</strong>;</p><p>平均情况：假设新元素插入到任何一个位置的概率相同，即i&#x3D;1,2,3，…，length+1的概率都是p&#x3D;1&#x2F;n+1</p><p>​平均循环次数&#x3D;n&#x2F;2 &#x3D;&gt; <strong>平均时间复杂度 &#x3D; O(n)</strong>;</p><h1 id="顺序表的基本操作——删除"><a href="#顺序表的基本操作——删除" class="headerlink" title="顺序表的基本操作——删除"></a>顺序表的基本操作——删除</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> data[MaxSize];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SqList&amp; L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i++)</span><br><span class="line">        L.data[i] = <span class="number">0</span>;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(SqList&amp; L, <span class="type">int</span> i, <span class="type">int</span>&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">0</span> || i&gt;L.length)    <span class="comment">// 判断i的范围是否有效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = L.data[i - <span class="number">1</span>];             <span class="comment">//  将被删除元素的值赋给e</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; L.length; j++) <span class="comment">//将第i个位置后的元素前移</span></span><br><span class="line">        L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">    L.length--;             <span class="comment">//  线性表的长度减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqList L;   <span class="comment">//声明一个顺序表</span></span><br><span class="line">    <span class="built_in">InitList</span>(L);    <span class="comment">//初始化顺序表</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="type">int</span> e = <span class="number">-1</span>; <span class="comment">//用变量e把删除的元素“带回来”</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ListDelete</span>(L, <span class="number">3</span>, e))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;已删除第三个元素，删除元素值为%d&quot;</span>\n, e);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;位序i不合法，删除失败\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除操作的时间复杂度</p><p>L.data[j - 1] &#x3D; L.data[j];</p><p><strong>最好情况</strong>：删除表尾元素，不需要移动其他元素<br>                    i &#x3D;n，循环o次;<strong>最好时间复杂度&#x3D;o(1)</strong><br><strong>最坏情况</strong>：删除表头元素，需要将后续的n-1个元素全都向前移动<br>                    i&#x3D; 1，循环n-1次;<strong>最坏时间复杂度&#x3D; O(n)</strong>;<br><strong>平均情况</strong>：假设删除任何一个元素的概率相同，即i&#x3D; 1,2,3. … , length 的概率都是p &#x3D;1&#x2F;n</p><p>​平均循环次数&#x3D;n-1&#x2F;2,<strong>平均时间复杂度&#x3D;O(n)</strong></p><h1 id="知识回顾与重要考点"><a href="#知识回顾与重要考点" class="headerlink" title="知识回顾与重要考点"></a>知识回顾与重要考点</h1><p><img src="/../images/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构,顺序表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表的顺序表示和实现</title>
      <link href="/2023/05/04/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/05/04/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="线性表的存储结构"><a href="#线性表的存储结构" class="headerlink" title="线性表的存储结构"></a>线性表的存储结构</h1><p>在计算机内，线性表有两种基本的存储结构：</p><p><strong>顺序存储结构</strong>和<strong>链式存储结构</strong>。</p><h1 id="线性表的顺序存储表示"><a href="#线性表的顺序存储表示" class="headerlink" title="线性表的顺序存储表示"></a>线性表的顺序存储表示</h1><p>线性表的顺序表示又称为<strong>顺序存储结构</strong>或顺序映像。<br><strong>顺序存储定义</strong>:把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。</p><p><img src="/../images/%E7%BA%BF%E6%80%A7%E8%A1%A82.png"></p><p>线性表的第1个数据元素a1的存储位置，称作线性表的<strong>起始位置</strong>或<strong>基地址</strong>。</p><p><img src="/../images/%E7%BA%BF%E6%80%A7%E8%A1%A83.png"></p><h2 id="顺序表中元素存储位置的计算"><a href="#顺序表中元素存储位置的计算" class="headerlink" title="顺序表中元素存储位置的计算"></a>顺序表中元素存储位置的计算</h2><p>如果每个元素占用8个存储单元，ai存储位置是2000单元，则ai+1存储位置是?<br>                        2008单元<br>假设线性表的每个元素需占l个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足关系:<br>                     <font color="orange"> LOC(ai+1)&#x3D; LOC( ai) +l</font><br>由此，所有数据元素的存储位置均可由第一个数据元素的存储位置得到:</p><p>​                     <font color="orange"> LOC(ai) &#x3D; LOC(a1)+ (i -1)×l</font></p><h2 id="线性表的顺序存储表示-1"><a href="#线性表的顺序存储表示-1" class="headerlink" title="线性表的顺序存储表示"></a>线性表的顺序存储表示</h2><p>$$<br>顺序表（元素）<br>\left{<br>\begin{aligned}<br>地址连续 \<br>依次存放 \<br>随机存取 \<br>类型相同 \<br>\end{aligned}<br>\right}<br>数组（元素）<br>\Rightarrow<br>用一维数组表示顺序表<br>$$</p><p>$$<br>\left.<br>\begin{aligned}<br>线性表长可变（删除）\<br>数组长度不可动态定义\<br>\end{aligned}<br>\right}<br>\Rightarrow<br>用一变量表示顺序表的长度属性<br>$$</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define LIST_INIT_SIZE 100 //线性表存储空间的初始分配量</span><br><span class="line">typedef struct&#123;</span><br><span class="line">   ElemType elem[LIST_INIT_SIZE];</span><br><span class="line">   int length; //当前长度</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><h2 id="多项式的顺序存储结构类型定义"><a href="#多项式的顺序存储结构类型定义" class="headerlink" title="多项式的顺序存储结构类型定义"></a>多项式的顺序存储结构类型定义</h2><p><img src="/../images/%E7%BA%BF%E6%80%A7%E8%A1%A84.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MAXSIZE 1000 //多项式可能达到的最大长度</span><br><span class="line"></span><br><span class="line">typedef struct &#123;     //多项式非零项的定义</span><br><span class="line"> float p;//系数</span><br><span class="line"> int e;//指数</span><br><span class="line">&#125;Polynomial;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">Polynomial *elem;//存储空间的基地址</span><br><span class="line">int length;//多项式中当前项的个数</span><br><span class="line">&#125;SqList; //多项式的顺序存储结构类型为SqList</span><br></pre></td></tr></table></figure><h3 id="图书表的顺序存储结构类型定义"><a href="#图书表的顺序存储结构类型定义" class="headerlink" title="图书表的顺序存储结构类型定义"></a><strong>图书表的顺序存储结构类型定义</strong></h3><p><img src="/../images/%E5%9B%BE%E4%B9%A6%E8%A1%A8.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MAXSIZE 10000</span><br><span class="line"> //图书表可能达到的最大长度</span><br><span class="line">typedef struct &#123;  //图书信息定义</span><br><span class="line">char no[20];//图书ISBN</span><br><span class="line">char name[50];//图书名字</span><br><span class="line">float price;//图书价格</span><br><span class="line">&#125;Book;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line"> Book *elem;//存储空间的基地址</span><br><span class="line"> int length;//图书表中当前图书个数</span><br><span class="line">&#125;SqList;//图书表的顺序存储结构类型为SqList</span><br></pre></td></tr></table></figure><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="元素类型说明"><a href="#元素类型说明" class="headerlink" title="元素类型说明"></a>元素类型说明</h2><p>顺序表类型定义</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">ElemType data[];</span><br><span class="line">int length;</span><br><span class="line">&#125;SqList; //顺序表类型</span><br></pre></td></tr></table></figure><p>ElemType 为 data[]的数据类型，根据需要更改。</p><p>如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef char ElemType;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef int ElemType</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">float p;</span><br><span class="line">int e;</span><br><span class="line">&#125;Polynomial;</span><br><span class="line"></span><br><span class="line">typedef stuct&#123;</span><br><span class="line">Polynomial *elem;</span><br><span class="line">int length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><h2 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h2><p><strong>数组静态分配</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">ElemType data[MaxSize];</span><br><span class="line">int length;</span><br><span class="line">&#125;SqList; //顺序表类型</span><br></pre></td></tr></table></figure><p><strong>数组动态分配</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">ElemType *data;</span><br><span class="line">int length;</span><br><span class="line">&#125;SqList; //顺序表类型</span><br></pre></td></tr></table></figure><p><strong>C语言的内存动态分配</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SqList L;</span><br><span class="line">L.data=(ElemType*)malloc(sizeof(ElemType)*Maxsize);</span><br></pre></td></tr></table></figure><ul><li>malloc(m)函数，开辟m字节长度的地址空间，并返回这段空间的首地址</li><li>sizeof(x)运算，计算变量x的长度</li><li>free(p)函数，释放指针p所指变量的存储空间，即彻底删除一个变量</li></ul><p><font color="orange"><strong>需要加载头文件：&lt;stdlib.h&gt;</strong></font></p><h2 id="传值方式"><a href="#传值方式" class="headerlink" title="传值方式"></a>传值方式</h2><p>把实参的值传送给函数局部工作区相应的副本中，函数使用这个副本执行必要的功能。函数修改的是副本的值，实参的值不变</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream.h&gt;</span><br><span class="line">void swap(float m,float n)</span><br><span class="line">&#123;</span><br><span class="line">float temp;</span><br><span class="line">temp = m;</span><br><span class="line">m = n;</span><br><span class="line">n = temp;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">float a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">swap(a,b);</span><br><span class="line">cout&lt;&lt;a&lt;&lt;endl&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传地址方式–指针变量作参数"><a href="#传地址方式–指针变量作参数" class="headerlink" title="传地址方式–指针变量作参数"></a><strong>传地址方式–指针变量作参数</strong></h3><p><strong>形参变化影响实参</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream.h&gt;</span><br><span class="line">void swap(float *m,float *n)&#123;</span><br><span class="line">    float t;</span><br><span class="line">    t = *m;</span><br><span class="line">    *m = *n;</span><br><span class="line">    *n = t;</span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line">    float a,b,*p1,*p2;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    p1=&amp;a;</span><br><span class="line">    p2=&amp;b;</span><br><span class="line">    swap(p1,p2);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>形参变化不影响实参</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void swap(float *m,float *n)</span><br><span class="line">&#123;</span><br><span class="line">    float *t;</span><br><span class="line">    t=m;</span><br><span class="line">    m=n;</span><br><span class="line">    n=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传地址方式-数组名作参数"><a href="#传地址方式-数组名作参数" class="headerlink" title="传地址方式 - - 数组名作参数"></a>传地址方式 - - 数组名作参数</h3><p>传递的是数组的首地址</p><p>对形参数组所做的任何改变都将反映到实参数组中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream.h&gt;</span><br><span class="line">void sub(char b[])</span><br><span class="line">&#123;</span><br><span class="line">b[ ]=“world&quot;;</span><br><span class="line">&#125;</span><br><span class="line">void main(void)&#123;</span><br><span class="line">char a[10]=&quot;hello&quot;;</span><br><span class="line">sub(a);</span><br><span class="line">cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传地址方式-——-引用类型作参数"><a href="#传地址方式-——-引用类型作参数" class="headerlink" title="传地址方式 —— 引用类型作参数"></a>传地址方式 —— 引用类型作参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream.h&gt;</span><br><span class="line">void swap(float &amp;m,float &amp;n)&#123;</span><br><span class="line">    float temp;</span><br><span class="line">    temp = m;</span><br><span class="line">    m = n;</span><br><span class="line">    n = temp;</span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line">    float a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    swap(a,b);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="引用类型作参数的三点说明"><a href="#引用类型作参数的三点说明" class="headerlink" title="引用类型作参数的三点说明"></a>引用类型作参数的三点说明</h4><p>(1）传递引用给函数与传递指针的效果是一样的，<strong>形参变化实参也发生变化</strong>。</p><p>(2）引用类型作形参，在内存中并没有产生实参的副本，它<strong>直接对实参操作</strong>;而一般变量作参数，形参与实参就占用不同的存储单元，所以<strong>形参变量的值是实参变量的副本</strong>。因此，当<strong>参数传递的数据量较大</strong>时，用引用比用一般变量传递参数的时间和空间效率都好。</p><p>(3）指针参数虽然也能达到与使用引用的效果，但在被调函数中需要重复使用“*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差;另一方面，在主调函数的调用点处，必须用变量的地址作为实参。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性表,顺序存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表定义和特点</title>
      <link href="/2023/04/29/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9/"/>
      <url>/2023/04/29/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="线性表的定义和特点"><a href="#线性表的定义和特点" class="headerlink" title="线性表的定义和特点"></a>线性表的定义和特点</h1><p><img src="/../images/%E7%BA%BF%E6%80%A7%E8%A1%A8.png"></p><p>线性表是具有<strong>相同特性</strong>的数据元素的一个<strong>有限序列</strong></p><p> <img src="/../images/%E7%BA%BF%E6%80%A7%E8%A1%A81.png"></p><ul><li><h2 id="线性表-Linear-List"><a href="#线性表-Linear-List" class="headerlink" title="线性表(Linear List) :"></a>线性表(Linear List) :</h2><p>由**n(n≥0)**个数据元素(结点)a1, a2,…a,组成的有限序列。</p><ul><li><p>其中<strong>数据元素</strong>的个数n定义为表的<strong>长度</strong>。</p></li><li><p>当n&#x3D;0时称为<strong>空表</strong></p></li><li><p>将非空的线性表(n&gt;0)记作:(a1, a2, …an)</p></li><li><p>这里的数据元素a;(1≤i≤n)只是一个抽象的符号，其具体含义在不同的情况下可以不同。</p></li></ul></li></ul><h3 id="线性表的逻辑特征"><a href="#线性表的逻辑特征" class="headerlink" title="线性表的逻辑特征"></a>线性表的逻辑特征</h3><ul><li><p>在非空的线性表，有且仅有一个开始结点a1，它没有直接前趋，而仅有一个直接后继a2;</p></li><li><p>有且仅有一个终端结点an，它没有直接后继，而仅有一个直接前趋a(n-1);</p></li><li><p>其余的内部结点a;(2≤i≤n-1)都有且仅有一个直接前趋a(i-1)和一个直接后继a(i+1)。</p><p><font color="orange">线性表是一种的典型的线性结构</font></p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>线性表中数据元素的类型可以为<font color="blue"><strong>简单类型</strong></font>，也可以为<font color="blue"><strong>复杂类型</strong></font>。</li><li>许多实际应用问题所涉的基本操作有很大相似性，不应为每个具体应用单独编写一个程序。</li><li>从具体应用中抽象出共性的<font color="blue"><strong>逻辑结构和基本操作</strong></font>(抽象数据类型)，然后实现其<font color="blue"><strong>存储结构和基本操作</strong></font>。</li></ul><h1 id="线性表的类型定义"><a href="#线性表的类型定义" class="headerlink" title="线性表的类型定义"></a>线性表的类型定义</h1><p>抽象数据类型线性表的定义如下：</p><p>ADT List{</p><p>​<strong>数据对象</strong>:D&#x3D; {ai | ai属于Elemset, (i&#x3D;1,2,n, n≥0)}</p><p>​        <strong>数据关系</strong>:R&#x3D;{&lt;ai-1,ai≥ |ai-1,ai属于D, (i&#x3D;2,3….n)}</p><p>​<strong>基本操作</strong>:<br>​<strong>lnitList(&amp;L)</strong>;</p><p>​<strong>DestroyList(&amp;L)</strong>;</p><p>​<strong>Listlnsert(&amp;L,i,e)</strong>; </p><p>​<strong>ListDelete(&amp;L,i,&amp;e)</strong>;</p><p>​….等等<br>}ADT List</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a><strong>基本操作</strong></h2><ul><li><p><strong>InitList(&amp;L) (Initialization List)</strong></p><ul><li>操作结果：构造一个空的线性表L</li></ul></li><li><p><strong>DestroyList(&amp;L)</strong></p><ul><li><p>初始条件：线性表L已经存在。</p></li><li><p>操作结果：销毁线性表L。</p></li></ul></li><li><p><strong>ClearList(&amp;L)</strong></p><ul><li>初始条件：线性表L已经存在。</li><li>操作结果：将线性表L重置为空表。</li></ul></li><li><p><strong>ListEmpty(L)</strong></p><ul><li>初始条件：线性表L已经存在。</li><li>操作结果：若线性表L为空表，则返回TURE；否则返回FALSE。</li></ul></li><li><p><strong>ListLength(L)</strong></p><ul><li>初始条件：线性表L已经存在。</li><li>操作结果：返回线性表L中的数据元素个数。</li></ul></li><li><p><strong>GetElem(L,i,&amp;e)</strong></p><ul><li>初始条件: 线性表L已经存在，1&lt;&#x3D;i&lt;&#x3D;ListLength(L)。</li><li>操作结果：用e返回线性表L中第i个数据元素的值。</li></ul></li><li><p><strong>LocateElem(L,e,compare())</strong></p><ul><li>初始条件：线性表L已经存在，compare()是数据元素判定函数。</li><li>操作结果：返回L中第1个与e满足compare()的数据元素的位序。若这样的数据元素不存在则返回值为0。</li></ul></li><li><p><strong>PriorElem(L,cur_e,&amp;pre_e)</strong></p><ul><li>初始条件：线性表L已经存在。</li><li>操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败；pre_e无意义。</li></ul></li><li><p><strong>NextElem(L,cur_e,&amp;next_e)</strong></p><ul><li>初始条件：线性表L已经存在。</li><li>操作结果：若cur_e是L的数据元素，且不是第最后个，则用next_e返回它的后继，否则操作失败，next_e无意义。</li></ul></li><li><p><strong>Listlnsert(&amp;L, i, e)</strong></p><ul><li><p>初始条件：线性表L已经存在，1&lt;&#x3D;i&lt;&#x3D;ListLength(L)+1。</p></li><li><p>操作结果：在L的第i个位置之前插入新的数据元素e, L的长度加一。</p><p>插入元素e之前(长度为n): (a1,a2,….,ai-1,ai,…,an)<br>插入元素e之后（长度为n+1) :(a1,a2,…,ai-1,e,ai,…,an)</p></li></ul></li><li><p><strong>ListDelete(&amp;L,i,&amp;e)</strong></p><ul><li>初始条件：线性表L已经存在，1&lt;&#x3D;i&lt;&#x3D; ListLength(L)。</li><li>操作结果：删除L的第i个数据元素,并用e返回其值,L的长度减一。</li><li>删除前(长度为n )：( a1,a2,…,ai-1, ai, ai+1,…,an)</li><li>删除后(长度为n -1 )：(a1,a2,…,ai-1, ai+1,…,an)</li></ul></li><li><p><strong>ListTraverse(&amp;L,visited())</strong></p><ul><li>初始条件：线性表L已经存在</li><li>操作结果：依次对线性表中每个元素调用visited()</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本概念和术语</title>
      <link href="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/"/>
      <url>/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="数据-1"><a href="#数据-1" class="headerlink" title="数据"></a>数据</h2><ul><li><p>是能输入计算机且能被计算机处理的各种符号的集合</p></li><li><p>信息的载体</p></li><li><p>是对客观事物符号化的表示</p></li><li><p>能够被计算机识别、存储和加工</p></li></ul><p><strong>包括</strong></p><ul><li>数值型的数据： 整数、实数等</li><li>非数值型的数据： 文字、图像、图形、声音等</li></ul><h1 id="数据元素和数据项"><a href="#数据元素和数据项" class="headerlink" title="数据元素和数据项"></a>数据元素和数据项</h1><h2 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h2><ul><li>是数据的<strong>基本单位</strong>，在计算机程序中通常作为一个整体进行考虑和处理。</li><li>也简称为元素，或称为记录、结点或顶点。</li><li>一个<strong>数据元素</strong>可由若干个<strong>数据项</strong>组成</li></ul><h2 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h2><ul><li>构成数据元素的不可分割的<strong>最小单位</strong>。</li><li>数据、数据元素、数据项三者之间的关系：</li></ul><p>​          <strong>数据  &gt;  数据  &gt;  数据项</strong> </p><p>​      例如： 学生表  个人记录  学号、姓名…</p><h1 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h1><ul><li>是<strong>性质相同的数据元素的集合</strong>，是数据的一个子集。</li></ul><p>例如： </p><ul><li><strong>整数</strong>数据对象是集合N&#x3D;{0, 1, 2….}</li><li><strong>字母</strong>字符数据对象是集合C&#x3D;{‘A’，‘B’,…}</li></ul><h1 id="数据元素与数据对象"><a href="#数据元素与数据对象" class="headerlink" title="数据元素与数据对象"></a>数据元素与数据对象</h1><ul><li><p>数据元素–组成数据的基本单位</p><ul><li>与数据的关系： 是集合的个体</li></ul></li><li><p>数据对象–性质相同的数据元素的集合</p><ul><li>与数据的关系是： 集合的子集</li></ul></li></ul><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>数据元素不是孤立存在的，它们之间存在着某种关系，<strong>数据元素相互之间的关系称为结构</strong></li><li>是指<strong>相互之间存在一种或多种特定关系</strong>的数据元素集合</li><li>或者说，数据结构是<strong>带结构</strong>的数据元素的集合</li></ul><h2 id="数据结构包括以下三个方面的内容"><a href="#数据结构包括以下三个方面的内容" class="headerlink" title="数据结构包括以下三个方面的内容:"></a>数据结构包括以下三个方面的内容:</h2><ol><li>数据元素之间的逻辑关系，也称为<strong>逻辑结构</strong>。</li><li>数据元素及其关系在计算机内存中的表示(又称为<strong>映像</strong>)），称为数据的<strong>物理结构</strong>或数据的存储结构。</li><li>数据的<strong>运算和实现</strong>，即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现。</li></ol><h1 id="数据结构的两个层次"><a href="#数据结构的两个层次" class="headerlink" title="数据结构的两个层次"></a>数据结构的两个层次</h1><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><ul><li>描述数据元素之间的逻辑关系</li><li>与数据的存储无关，独立于计算机</li><li>是从具体问题抽象出来的数学模型</li></ul><h2 id="物理结构-存储结构"><a href="#物理结构-存储结构" class="headerlink" title="物理结构(存储结构)"></a>物理结构(存储结构)</h2><ul><li>数据元素及其关系在计算机存储器中的结构(存储方式)</li><li>是数据结构在计算机中的表示</li></ul><h2 id="逻辑结构与存储结构的关系"><a href="#逻辑结构与存储结构的关系" class="headerlink" title="逻辑结构与存储结构的关系:"></a>逻辑结构与存储结构的关系:</h2><ul><li>存储结构是逻辑关系的映象与元素本身的映象。<br>逻辑结构是数据结构的抽象，存储结构是数据结构的实现</li><li>两者综合起来建立了数据元素之间的结构关系。</li></ul><h2 id="逻辑结构的种类"><a href="#逻辑结构的种类" class="headerlink" title="逻辑结构的种类"></a>逻辑结构的种类</h2><h3 id="划分方法一"><a href="#划分方法一" class="headerlink" title="划分方法一"></a>划分方法一</h3><p><strong>(1）线性结构</strong><br>            有且仅有一个开始和一个终端结点，并且所有结点都最多只有一个直接前趋和一个直接后继。<br>            例如:线性表、栈、队列、串</p><p><strong>(2）非线性结构</strong><br>           一个结点可能有多个直接前趋和直接后继</p><p>​           例如:树、图</p><h3 id="划分方式二——四类基本逻辑结构"><a href="#划分方式二——四类基本逻辑结构" class="headerlink" title="划分方式二——四类基本逻辑结构"></a>划分方式二——四类基本逻辑结构</h3><ol><li>**集合结构:**结构中的数据元素之间除了同属于一个集合的关系外，无任何其它关系。</li><li><strong>线性结构</strong>:结构中的数据元素之间存在着一对一的线性关系。</li><li>**树形结构:**结构中的数据元素之间存在着一对多的层次关系。</li><li><strong>图状结构或网状结构</strong>:<strong>结构中的数据元素之间存在着</strong>多对多**的任意关系。</li></ol><h3 id="四种基本的存储结构–1"><a href="#四种基本的存储结构–1" class="headerlink" title="四种基本的存储结构–1"></a>四种基本的存储结构–1</h3><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构:"></a>顺序存储结构:</h4><ul><li>用一组<strong>连续</strong>的存储单元<strong>依次</strong>存储数据元素，<strong>数据元素之间的逻辑关系</strong>由元素的<strong>存储位置</strong>来表示。</li><li>C语言中用<strong>数组</strong>来实现顺序存储结构</li></ul><h3 id="四种基本的存储结构–2"><a href="#四种基本的存储结构–2" class="headerlink" title="四种基本的存储结构–2"></a>四种基本的存储结构–2</h3><h4 id="链接存储结构"><a href="#链接存储结构" class="headerlink" title="链接存储结构:"></a>链接存储结构:</h4><ul><li>用一组<strong>任意</strong>的存储单元存储数据元素，数据元素之间的逻辑关系用<strong>指针</strong>来表示。</li><li>C语言中用指针来实现链式存储结构<br>例:(bat, cat, eat……,mat)</li></ul><h3 id="四种基本的存储结构–3索引存储结构"><a href="#四种基本的存储结构–3索引存储结构" class="headerlink" title="四种基本的存储结构–3索引存储结构"></a>四种基本的存储结构–3索引存储结构</h3><ul><li>在存储结点信息的同时，还建立附加的<strong>索引表</strong>。</li><li>索引表中的每示项称为、一个<strong>索引项</strong>，<br>索引项的<strong>一般形式</strong>是:(关键字，地址)</li><li>关键字是能<strong>唯一标识</strong>一个结点的那些数据项。</li><li>若每个结点在索引表中都有一个索引项，则该索引表称之为<strong>稠密索引</strong>(Dense Index)。若一组结点在索引表中只对应一个索引项，则该索引表称之为<strong>稀疏索引</strong>(Sparse Index)。</li></ul><h3 id="四种基本的存储结构–4"><a href="#四种基本的存储结构–4" class="headerlink" title="四种基本的存储结构–4"></a>四种基本的存储结构–4</h3><h4 id="散列存储结构"><a href="#散列存储结构" class="headerlink" title="散列存储结构"></a>散列存储结构</h4><ul><li><p>根据结点的关键字直接计算出该结点的存储地址。</p><p><img src="/../images/key1.png"></p><p>得到的散列表如下:</p><p><img src="/../images/%E6%95%A3%E5%88%97%E8%A1%A8.png"></p></li></ul><h1 id="数据类型和抽象数据类型"><a href="#数据类型和抽象数据类型" class="headerlink" title="数据类型和抽象数据类型"></a>数据类型和抽象数据类型</h1><ul><li><p>在使用高级程序设计语言编写程序时，必须对程序中出现的每个变量、常量或表达式，明确说明它们所属的<strong>数据类型</strong>。</p><ul><li>例如，C语言中:<ul><li>·提供int，char, float, double等基本数据类型</li><li>数组、结构、共用体、枚举等构造数据类型</li><li>还有指针、空(void)类型</li><li>用户也可用typedef自己定义数据类型</li></ul></li></ul></li><li><p>一些最基本数据结构可以用数据类型来实现，如数组、字符串等;</p></li><li><p>而另一些常用的数据结构，如栈、队列、树、图等，不能直接用数据类型来表示。</p></li><li><p>高级语言中的数据类型明显地或隐含地规定了在程序执行期间变量和表达的所有可能的取值范围，以及在这些数值范围上所允许进行的操作。</p><ul><li><p>例如，C语言中定义变量达int类型，就表示i是[-min,max]范围的整数在这个整数集上可以进行+、-、*、\、%等操作</p></li><li><p><strong>数据类型的作用</strong></p><ul><li><p>约束变量或常量的取值范围</p></li><li><p>约束变量或常量的操作。</p></li></ul></li></ul></li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li><p>定义：<strong>数据类型</strong>是一组性质相同的<strong>值的集合</strong>以及定义于这个值集合上的<strong>一组操作</strong>的总称。</p><p><strong>数据类型&#x3D;值的集合+值集合上的一组操作</strong></p></li></ul><h3 id="抽象数据模型"><a href="#抽象数据模型" class="headerlink" title="抽象数据模型"></a>抽象数据模型</h3><p><strong>是指一个数学模型以及定义在此数学模型上的一组操作</strong>。</p><ul><li>由用户定义,从问题抽象出<strong>数据模型</strong>（逻辑结构)</li><li>还包括定义在数据模型上的一组<strong>抽象运算</strong>(相关操作)</li><li>不考虑计算机内的具体存储结构与运算的具体实现算法</li></ul><h3 id="抽象数据类型的形式定义"><a href="#抽象数据类型的形式定义" class="headerlink" title="抽象数据类型的形式定义"></a>抽象数据类型的形式定义</h3><p>抽象数据类型可用(D，S,P)<strong>三元组</strong>表示。</p><p>其中:D是<strong>数据对象</strong>;</p><p>​         S是D上的<strong>关系集</strong>;</p><p>​         P是对D的<strong>基本操作集</strong>。</p><p><strong>一个抽象数据类型的定义格魂如下:</strong><br>ADT   <strong>抽象数据类型名</strong>{</p><p><strong>数据对象;&lt;数据对象的定义&gt;</strong></p><p><strong>数据关系:&lt;数据关系的定义&gt;</strong></p><p><strong>基本操作:&lt;基本操作的定义&gt;</strong></p><p>}ADT   <strong>抽象数据类型名</strong></p><p>其中:</p><ul><li><p>数据对象、数据关系的定义用伪代码描述</p></li><li><p>基本操作的定义格式为:</p><ul><li>基本操作名(参数表)</li><li>初始条件:〈初始条件描述〉</li><li>操作结果:〈操作结果描述〉</li></ul></li></ul><p><strong>基本操作</strong>定义格式说明:</p><p><strong>参数表</strong>:赋值参数只为操作提供输入值。</p><p>​            引用参数以&amp;打头，除可提供输入值外，还将返回操作结果。</p><p><strong>初始条件</strong>:描述操作执行之前数据结构和参数应满足的条件，若不满足，则操作失败，并返回相应出错信息。若初始条件为空，则省略之。<br><strong>操作结果</strong>:说明操作正常完成之后，数据结构的变化状况和应返回的结果。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组指针和指针数组</title>
      <link href="/2023/04/25/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/"/>
      <url>/2023/04/25/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数组指针和指针数组"><a href="#数组指针和指针数组" class="headerlink" title="数组指针和指针数组"></a>数组指针和指针数组</h1><p>首先，理解一下数组指针和指针数组这两个名词：</p><p>“数组指针”和“指针数组”，只要在名词中间加上“的”字，就知道中心了——</p><p>数组的指针：是一个指针，什么样的指针呢？指向数组的指针。</p><p>指针的数组：是一个数组，什么样的数组呢？装着指针的数组。</p><p>然后，需要明确一个优先级顺序：()&gt;[]&gt;*，所以：</p><p>(*p)[n]：根据优先级，先看括号内，则p是一个指针，这个指针指向一个一维数组，数组长度为n，这是“数组的指针”，即数组指针；</p><p><em>p[n]：根据优先级，先看[]，则p是一个数组，再结合</em>，这个数组的元素是指针类型，共n个元素，这是“指针的数组”，即指针数组。</p><p>根据上面两个分析，可以看出，p是什么，则词组的中心词就是什么，即数组“指针”和指针“数组”。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p1[<span class="number">5</span>]；</span><br><span class="line"><span class="type">int</span> (*p2)[<span class="number">5</span>]；</span><br></pre></td></tr></table></figure><p>首先，对于语句“<code>int*p1[5]</code>”，因为“[]”的优先级要比“*”要高，所以 <code>p1</code> 先与“[]”结合，构成一个数组的定义，数组名为 p1，而“<code>int*</code>”修饰的是数组的内容，即数组的每个元素。也就是说，该数组包含 5 个指向 int 类型数据的指针。</p><p>其次，对于语句“<code>int(*p2)[5]</code>”，“()”的优先级比“[]”高，“<code>*</code>”号和 <code>p2</code> 构成一个指针的定义，指针变量名为 p2，而 int 修饰的是数组的内容，即数组的每个元素。也就是说，p2 是一个指针，它指向一个包含 5 个 int 类型数据的数组。</p><p>由此可见，对指针数组来说，首先它是一个数组，数组的元素都是指针，也就是说该数组存储的是指针，数组占多少个字节由数组本身决定；而对数组指针来说，首先它是一个指针，它指向一个数组，也就是说它是指向数组的指针。</p><h1 id="数组指针-p-n"><a href="#数组指针-p-n" class="headerlink" title="数组指针 (*p)[n]"></a>数组指针 <code>(*p)[n]</code></h1><p>数组指针：是指针——指向数组的指针。</p><pre><code>#include &lt;iostream&gt;int main()&#123;    //一维数组    int a[5] = &#123; 1, 2, 3, 4, 5 &#125;;    //步长为5的数组指针，即数组里有5个元素    int(*p)[5];    //把数组a的地址赋给p，则p为数组a的地址，则*p表示数组a本身    p = &amp;a;    //%p输出地址, %d输出十进制    //\n回车    //在C中，在几乎所有使用数组的表达式中，数组名的值是个指针常量，也就是数组第一个元素的地址，它的类型取决于数组元素的类型。    printf(&quot;%p\n&quot;, a); //输出数组名，一般用数组的首元素地址来标识一个数组，则输出数组首元素地址    printf(&quot;%p\n&quot;, p); //根据上面，p为数组a的地址，输出数组a的地址    printf(&quot;%p\n&quot;, *p); //*p表示数组a本身，一般用数组的首元素地址来标识一个数组    printf(&quot;%p\n&quot;, &amp;a[0]); //a[0]的地址    printf(&quot;%p\n&quot;, &amp;a[1]); //a[1]的地址    printf(&quot;%p\n&quot;, p[0]); //数组首元素的地址    printf(&quot;%d\n&quot;, **p); //*p为数组a本身，即为数组a首元素地址，则*(*p)为值，当*p为数组首元素地址时，**p表示首元素的值1    printf(&quot;%d\n&quot;, *p[0]); //根据优先级，p[0] 表示首元素地址，则*p[0]表示首元素本身，即首元素的值1    printf(&quot;%d\n&quot;, *p[1]); //为一个绝对值很大的负数，不表示a[1]...表示什么我还不知道    //将二维数组赋给指针    int b[3][4];    int(*pp)[4]; //定义一个数组指针，指向含4个元素的一维数组    pp = b; //将该二维数组的首地址赋给pp，也就是b[0]或&amp;b[0]，二维数组中pp=b和pp=&amp;b[0]是等价的    pp++; //pp=pp+1，该语句执行过后pp的指向从行b[0][]变为了行b[1][]，pp=&amp;b[1]    int k;    scanf_s(&quot;%d&quot;, &amp;k);    return 0;&#125;</code></pre><p><img src="/../images/szzz.png" alt="数组指针"></p><p>据上面二维数组可以得出，数组指针也称指向一维数组的指针，所以数组指针也称行指针。</p><h1 id="指针数组-p-n"><a href="#指针数组-p-n" class="headerlink" title="指针数组 *p[n]"></a>指针数组 *p[n]</h1><p>指针数组：是数组——装着指针的数组。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 1;</span><br><span class="line">int b = 2;</span><br><span class="line">int* p[2];</span><br><span class="line">p[0] = &amp;a;</span><br><span class="line">p[1] = &amp;b;</span><br><span class="line">printf(&quot;%p\n&quot;, p[0]); //a的地址</span><br><span class="line">printf(&quot;%p\n&quot;, &amp;a); //a的地址</span><br><span class="line">printf(&quot;%p\n&quot;, p[1]); //b的地址</span><br><span class="line">printf(&quot;%p\n&quot;, &amp;b); //b的地址</span><br><span class="line">printf(&quot;%d\n&quot;, *p[0]); //p[0]表示a的地址，则*p[0]表示a的值</span><br><span class="line">printf(&quot;%d\n&quot;, *p[1]); //p[1]表示b的地址，则*p[1]表示b的值</span><br><span class="line">//将二维数组赋给指针数组</span><br><span class="line">int* pp[3]; //一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2]，所以要分别赋值</span><br><span class="line">int c[3][4];</span><br><span class="line">for (int i = 0; i &lt; 3; i++)</span><br><span class="line">pp[i] = c[i];</span><br><span class="line">int k;</span><br><span class="line">scanf_s(&quot;%d&quot;, &amp;k);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/zzsz.png" alt="指针数组"></p><p>最后，从上文来看：</p><p>数组指针是一个指针变量，占有内存中一个指针的存储空间；</p><p>指针数组是多个指针变量，以数组的形式存储在内存中，占有多个指针的存储空间。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>提示：这里对文章进行总结：<br>1.数组指针简单理解为“数组的指针”，首先这个变量是一个指针，其次，”数组”修饰这个指针，意思是说这个指针存放着一个数组的首地址，或者说这个指针指向一个数组的首地址。<br>2.指针数组简单理解为“指针的数组”，首先这个变量是一个数组，其次，”指针p”修饰这个数组，意思是说这个数组的所有元素都是指针类型。<br>3.关于函数传参的问题：传递的参数：int *p[4] -&gt; 匹配需要的形参：int **p（指针数组或者二级指针）；传递的参数：int (*p)[4] -&gt; 匹配需要的形参：int (*p)[4]（不变）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数组指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my first blog</title>
      <link href="/2023/04/19/my-first-blog/"/>
      <url>/2023/04/19/my-first-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>这是我的第一篇博客</strong><br><em>在 Hexo 框架搭建的博客网站首页会显示文章的内容（默认显示文章的全部内容）</em><span id="more"></span></p><p><em>，如果当文章太长的时候就会显得十分冗余，所以我们有必要对其进行精简，只需在文章中使用 <!--more-->标志，表示只会显示标志前面的内容</em><br><a href="https://www.csdn.net/?ydreferer=aHR0cHM6Ly93d3cuYmFpZHUuY29tL2xpbms/dXJsPUxjdGIyOVNjc2dZOGV5eWZtdGZMT0NWVWYyUWlGNEs0R1FmS1Bxcll3NmEmd2Q9JmVxaWQ9ODFkMjUwYjMwMDA5ODAwMTAwMDAwMDA2NjQzZmI2ZTg=">csdn地址</a></p><p><img src="/../images/1.png" alt="1"></p><p><img src="https://pic1.zhimg.com/80/v2-ab55e2fc1fafd7b87c36ef40e9a61dc0_720w.webp" alt="baidu"><br>图片显示</p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> firstblog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/04/19/hello-world/"/>
      <url>/2023/04/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
